@ = require(['mho:std', 'sjs:nodejs/tempfile']);
var deployLoopback = @env.get('deployLoopback');
@info("deployLoopback: #{deployLoopback}");

@settings = require('./settings');
exports.servers = @settings.servers;
exports.createServer = function(props) {
	return @settings.server(null, props);
};

var Deployment = function(remote, serverInfo) {
	var serverId = serverInfo .. @get('id');
	this.apps = remote.apps .. @transform(function(remoteApps) {
		@info("transforming remote apps: #{remoteApps}");
		@assert.arrayOfObject(remoteApps);
		return remoteApps .. @map(function(app) {
			@info("transforming remote app: #{app}");
			var appId = app .. @get('id');
			var localSettings = @settings.app(serverId, appId);
			return {
				config: {
					central: app.config, // stored on server
					local: localSettings.config, // stored per-client
				},
				ctl: app,
				id: appId,
			};
		}) .. @sortBy(app -> app.config.central .. @first() .. @get('name'));
	});

	this.createApp = function(props) {
		var {central, local} = props;
		var localSettings = @settings.app(serverId, null, local);
		var config = localSettings.config .. @first();
		@info("Created local app settings", config);
		var remoteApp = remote.createApp(localSettings .. @get('id'), central);
		remoteApp .. @assert.ok();
		@info("Created app: #{app}");
	};

	this.destroyApp = function(id) {
		// TODO: also delete local app settings?
		// Not bothering yet, as they are trivially small and will need
		// garbage collection on all hosts that didn't trigger this deletion anyway.
		remote.destroyApp(id);
	};

	this.deploy = function(appId, log) {
		@assert.string(appId);
		var localAppSettings = @settings.app(serverInfo.id, appId);
		var settings = localAppSettings.config .. @first();
		var root = settings .. @get('path');
		var app = remote.getApp(appId);
		var config = app.config .. @first();
		@info("deploying #{config.name} (#{appId}) from #{root}");

		// XXX we should be able to use `tar` output directly,
		// but https://github.com/joyent/node/issues/6595
		@TemporaryFile {|tmp|
			try {
				@childProcess.run('tar', ['-cvzf', tmp.path, '-C', root, '.'], {stdio: ['ignore', 'ignore',2]});
			} catch(e) {
				throw new Error("`tar` failed: #{e}");
			}

			var payload = @Stream(function(emit) {
				console.log("READING!");
				var stream = tmp.readStream();
				var i=0;
				var chunk;
				var chunks=[];
				var lastTime = 0;
				var send = function(chunk) {
					if (chunks.length > 0) {
						console.log("[> chunk #{i}: #{chunks.length}]");
						console.log("[= chunk #{i++}: #{chunks.length}]");
						emit(Buffer.concat(chunks));
						chunks = [];
					}
				};
				while(true) {
					chunk = stream .. @read();
					if (chunk == null) {
						send();
						break;
					}
					chunks.push(chunk);

					var now = Date.now();
					if (Math.abs(now - lastTime) > 200) {
						// if last round-trip was less than 200ms ago, keep accumulating
						lastTime = now;
						send();
					}
				}
			});
			app.deploy(payload);
		}
	};
};


var connect;

if (deployLoopback) {
	// for easy testing: cut out the middle-man, and let the browser talk directly to the deployment API
	@env.set('anonymous-access', true);
	@warn("Allowing anonymous access - only use this during development");
	connect = function(creds, block) {
		block(require('../modules/deploy.api'));
	}
} else {
	@bridge = require('mho:rpc/bridge');
	connect = function(creds, block) {
		if (creds.ssh) {
			if (!@ssh) @ssh = require('./ssh');
			//creds.debug = @info;
			@ssh.Connect(creds) {|conn|
				var seedPort = 7079;
				// XXX make this path portable
				//conn .. @ssh.runSeed('/home/tim/dev/oni/conductance', seedPort) {||
					conn .. @ssh.proxyConnections(seedPort) {|path|
						@debug("Proxied: #{path}");
						var apiInfo = @http.json('http:///deploy.api?format=json', {socketPath: path});
						@debug('API INFO:', apiInfo);
						var transport = require('mho:rpc/aat-client').openTransport('http:///', {socketPath: path});
						@debug('transport', transport);
						@bridge.connect('XXX', {transport: transport, api:apiInfo}) {|conn|
							block(conn.api);
						}
					}
				//}
			}
		} else {
			var prefix = "https://";
			// XXX we should probably lock this down to testing use only, somehow
			if (creds.host .. @contains("://")) prefix = "";
			@bridge.connect("#{prefix}#{creds.host}:#{creds.port || 443}") {|conn|
				block(conn.api);
			}
		}
	};
}

exports.connect = function(serverId, block) {
	@assert.string(serverId);
	var server = @settings.server(serverId);
	var creds = server.config .. @first() .. @clone();

	if (creds.ssh) {
		// process privateKey
		@info("Connecting via SSH with credentials", creds);
		var pkDef = creds .. @get('privateKey', null);
		var agentDef = creds .. @get('agent', null);
		if (pkDef !== null) {
			var pk;
			switch(pkDef.type) {
				case 'key':
					@debug("reading ssh key #{pkDef.name}");
					pk = @fs.readFile(@path.join(process.env .. @get('HOME'), '.ssh', pkDef .. @get('name')));
					break;
				case 'file':
					@debug("reading ssh key file #{pkDef.path}");
					pk = @fs.readFile(pkDef .. @get('path'));
					break;
				default:
					@assert.fail("Unknown private key type: #{pkDef.type}");
			}
			creds.privateKey = pk;
		} else if (agentDef !== null) {
			// use env
			creds.agent = agentDef === true ? process.env .. @get('SSH_AUTH_SOCK') : agentDef;
			@debug("Using SSH agent socket #{creds.agent}");
		}

		connect(creds) {|api|
			// over SSH, assume deployment is available anonymously
			api = api.anonymous;
			block(new Deployment(api, server));
		}
	} else {
		// over HTTP(s), perform auth to the API
		connect(creds) {|api|
			api = api.authenticate(creds .. @get('token'));
			block(new Deployment(api, server));
		}
	}
};

exports.authenticate = function(serverId, password) {
	// XXX this is going over cleartext between index.app and the local server
	var server = @settings.server(serverId);
	var creds = server.config .. @first();
	var user = creds .. @get('username');
	connect(creds) {|api|
		@info("Logging in as: #{user}");
		var token = api.getToken(user, password);
		@info("Got token:", token);
		if (!token) return false;
		server.config.modify(c -> c .. @merge({token: token}));
		return true;
	}
}
