@ = require(['mho:std', 'sjs:nodejs/tempfile']);
var deployLoopback = @env.get('deployLoopback');
@warn("deployLoopback: #{deployLoopback}");

@settings = require('./settings');
exports.servers = @settings.servers;
exports.createServer = function(props) {
	return @settings.server(null, props);
};

var untangleConfig = function(conf) {
	var SERVER_CONFIG = ['name', 'centralVersion'];
	var server = {}, local = {};
	conf .. @ownPropertyPairs .. @each {|[k,v]|
		if (SERVER_CONFIG .. @hasElem(k)) {
			server[k] = v;
		} else {
			local[k] = v;
		}
	}
	return [server, local];
}

var Deployment = function(remote, serverInfo) {
	var serverId = serverInfo .. @get('id');
	this.apps = remote.apps .. @transform(function(remoteApps) {
		@info("transforming remote apps: #{remoteApps}");
		@assert.arrayOfObject(remoteApps);
		return remoteApps .. @map(function(app) {
			@info("transforming remote app: #{app}");
			var appId = app .. @get('id');
			var localSettings = @settings.app(serverId, appId);
			var combinedConfig = @observe(app.config, localSettings.config, function(conf, local) {
				@assert.ok(conf, 'remote config is undefined');
				@assert.ok(local, 'local config is undefined');
				return local .. @merge(conf);
			});

			combinedConfig.modify = function(func) {
				var modifyPart = function(settings, f, idx) {
					return settings.modify(function(current, unmodified) {
						var newval = f(current, unmodified);
						if (newval === unmodified) return unmodified;
						newval = untangleConfig(newval)[idx];
						if (current .. @eq(newval)) return unmodified;
						return newval;
					});
				};

				waitfor {
					localSettings.config .. modifyPart(func, 1);
				} and {
					app.config .. modifyPart(func, 0);
				}
			};

			return {
				config: combinedConfig,
				ctl: app,
				id: appId,
			};
		}) .. @sortBy(app -> app.config .. @first() .. @get('name'));
	});

	this.createApp = function(props) {
		var [server, local] = untangleConfig(props);
		var localSettings = @settings.app(serverId, null, local);
		var config = localSettings.config .. @first();
		@info("Created local app settings", config);
		var remoteApp = remote.createApp(localSettings .. @get('id'), server);
		remoteApp .. @assert.ok();
		@info("Created app: #{app}");
	};

	this.destroyApp = function(id) {
		// TODO: also delete local app settings?
		// Not bothering yet, as they are trivially small and will need
		// garbage collection on all hosts that didn't trigger this deletion anyway.
		remote.destroyApp(id);
	};

	this.deploy = function(appId, log) {
		@assert.string(appId);
		var appSettings = @settings.app(server.id, appId);
		var app = server.app(appId);
		var settings = app.config .. @first();
		log("Deploying #{settings.name}");
		var root = settings .. @get('path');
		@info("deploying #{appId} from #{root}");

		// XXX we should be able to use `tar` output directly,
		// but https://github.com/joyent/node/issues/6595
		@TemporaryFile {|tmp|
			try {
				@childProcess.run('tar', ['-cvzf', tmp.path, '-C', root, '.'], {stdio: ['ignore', 'ignore',2]});
			} catch(e) {
				throw new Error("`tar` failed: #{e}");
			}

			var payload = @Stream(function(emit) {
				console.log("READING!");
				var stream = tmp.readStream();
				var i=0;
				var chunk;
				var chunks=[];
				var lastTime = 0;
				var send = function(chunk) {
					if (chunks.length > 0) {
						console.log("[> chunk #{i}: #{chunks.length}]");
						console.log("[= chunk #{i++}: #{chunks.length}]");
						emit(Buffer.concat(chunks));
						chunks = [];
					}
				};
				while(true) {
					chunk = stream .. @read();
					if (chunk == null) {
						send();
						break;
					}
					chunks.push(chunk);

					var now = Date.now();
					if (Math.abs(now - lastTime) > 200) {
						// if last round-trip was less than 200ms ago, keep accumulating
						lastTime = now;
						send();
					}
				}
			});
			remote.deploy(payload);
		}
	};
};


var connect;

if (deployLoopback) {
	// for easy testing: cut out the middle-man, and let the browser talk directly to the deployment API
	connect = function(creds, block) {
		block(require('../modules/deploy.api'));
	}
} else {
	@ssh = require('./ssh');
	connect = function(creds, block) {
		@ssh.Connect(creds) {|conn|
			//conn .. @ssh.runSeed('/home/tim/dev/oni/conductance') {||
				conn .. @ssh.proxyConnections(7079) {|path|
					@info("Proxied: #{path}");
					var apiInfo = @http.json('http:///deploy.api?format=json', {socketPath: path});
					@info('API INFO:', apiInfo);
					var transport = require('mho:rpc/aat-client').openTransport('http:///', {socketPath: path});
					@info('transport', transport);
					require('mho:rpc/bridge').connect('XXX', {transport: transport, api:apiInfo}) {|conn|
						@info("got remote API", conn);
						block(conn.api);
					}
				}
			//}
		}
	};
}

exports.connect = function(serverId, block) {
	@assert.string(serverId);
	var server = @settings.server(serverId);
	var creds = server.config .. @first() .. @clone();
	
	// process privateKey
	@info("Connecting via SSH with credentials", creds);
	var pkDef = creds .. @get('privateKey', null);
	var agentDef = creds .. @get('agent', null);
	if (pkDef !== null) {
		var pk;
		switch(pkDef.type) {
			case 'key':
				@debug("reading ssh key #{pkDef.name}");
				pk = @fs.readFile(@path.join(process.env .. @get('HOME'), '.ssh', pkDef .. @get('name')));
				break;
			case 'file':
				@debug("reading ssh key file #{pkDef.path}");
				pk = @fs.readFile(pkDef .. @get('path'));
				break;
			default:
				@assert.fail("Unknown private key type: #{pkDef.type}");
		}
		creds.privateKey = pk;
	} else if (agentDef !== null) {
		// use env
		creds.agent = agentDef === true ? process.env .. @get('SSH_AUTH_SOCK') : agentDef;
		@debug("Using SSH agent socket #{creds.agent}");
	}

	connect(creds) {|api|
		block(new Deployment(api, server));
	}
};
