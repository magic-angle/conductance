// Germination server

@ = require('mho:std');
require('./modules/hub');
@etcd = require('seed:job/etcd');

var VERSION = 1;

var runningServerInfo = function(port) {
  try {
    var info = @http.json("http://localhost:#{port}/version");
    // XXX what should we do on version mismatch?
    return info;
  } catch(e) {
    if (e.message .. @contains('ECONNREFUSED')) return false;
    throw e;
  }
}

//----------------------------------------------------------------------
// function invoked by `conductance serve`
exports.serve = function(args) {
  var opts = args .. require('seed:env').parse([
    {
      names: ['host'],
      type: 'string',
      help: 'serve on address (default: "localhost". Use "any" to serve on any address")',
      'default': 'localhost',
    },
    {
      names: ['anonymous'],
      type: 'bool',
      help: 'allow full access to everyone',
      'default': false,
    },
    {
      names: ['use-existing'],
      type: 'bool',
      help: 'just exit successfully if there\'s already a server running',
      'default': false,
    },
    {
      names: ['ssl'],
      type: 'bool',
      help: 'serve over https (NOTE: uses the default conductance certificate, use for testing only)',
      'default': false,
    },
    {
      names: ['internal-address'],
      type: 'string',
      help: 'internal ip (or hostname) accessible via SSH to slaves',
      'default': false,
    },
    {
      names: ['cors'],
      type: 'bool',
      help: 'allow cors',
      'default': false,
    },
  ]);
  @env.set('anonymous-access', opts.anonymous);
  if (!@env.has('internalAddress')) {
    @assert.ok(opts.internal_address, "--internal-address");
    @env.set('internalAddress', opts.internal_address);
  }

  var versionInfo = {
    version: VERSION,
    config: module.id,
    pid: process.pid,
    node_env: process.NODE_ENV || null,
  };

  var routes = [
        @route.SystemRoutes(),
        @Route('version', {GET: function(req) {
          req .. @setHeader('content-type', 'text/json; charset=utf-8');
          req .. @setStatus(200);
          req.response.end(JSON.stringify(versionInfo, null, '  '));
        }}),
        @route.ExecutableDirectory('', @url.normalize('./modules/master', module.id) .. @url.toPath),
      ];

  if (opts.cors) {
    routes = routes .. @route.AllowCORS();
  }

  var host = opts.host == 'any' ? null : opts.host;
  var port = @env.get('port-master');

  try {
    require('seed:master/state').acquire();
  } catch(e) {
    if (!opts.use_existing) throw e;
    @info("Couldn't acquire lockfile - checking for an existing server on port #{port}");
    var serverInfo = runningServerInfo(port);
    if (serverInfo) {
      console.warn("Server already running on port #{port}:", serverInfo);
      return;
    }
    throw e;
  }

  var ssl = opts.ssl;

  var address = @Port(port, host);
  if (opts.ssl) {
    address = address.ssl({
      key: @fs.readFile("#{@env.conductanceRoot}ssl/insecure-localhost.key"),
      cert: @fs.readFile("#{@env.conductanceRoot}ssl/insecure-localhost.crt")
    });
  }

  // discard operations from previous master
  var etcd = @env.get('etcd');
  @etcd.tryOp( -> etcd.del('app/op/', {recursive:true}));

  waitfor {
    require('seed:job/master').main(etcd, {
      //balanceTime: 5,
      balanceTime: 10 * 60,
    });
  } or {
    @server.run({
      address: address,
      routes: routes,
    });
  }
};

//exports.serve = function(args) {
//  waitfor {
//    // XXX shouldn't the process automatically get killed on HUP or something?
//    process.stdin .. @wait('close');
//    console.warn("STDIN CLOSED");
//  } or {
//    serve.apply(this,arguments);
//  }
//};

exports.systemd = function() {
  @systemd = require('./common.mho').systemdWrap;
  return @systemd.Group("seed-master", {
    "server": [
      @systemd.Service(),
    ]
  });
};
