@ = require('mho:std');
require('./modules/hub');
@etcd = require('seed:job/etcd');
@response = require('mho:server/response');

var runningServerInfo = function(port) {
  try {
    var info = @http.json("http://localhost:#{port}/version");
    // XXX what should we do on version mismatch?
    return info;
  } catch(e) {
    if (e.message .. @contains('ECONNREFUSED')) return false;
    throw e;
  }
}

//----------------------------------------------------------------------
exports.serve = function(args) {
  var common = require('./common.mho');
  var opts = args .. require('seed:env').parse([
    {
      names: ['anonymous'],
      type: 'bool',
      help: 'allow full access to everyone',
      'default': false,
    },
    {
      names: ['use-existing'],
      type: 'bool',
      help: 'just exit successfully if there\'s already a server running',
      'default': false,
    },
    {
      names: ['ssl'],
      type: 'bool',
      help: 'serve over https (NOTE: uses the default conductance certificate, use for testing only)',
      'default': false,
    },
    {
      name: 'multi',
      type: 'bool',
      help: 'allow multiple deploy destinations (advanced use only)',
      'default': false,
    },
  ]);
  @env.set('anonymous-access', opts.anonymous);
  @env.set('multi-deploy-destinations', opts.multi);

  var verification = require('seed:master/verification');
  var routes = [
    @route.SystemRoutes(),
    
    // add /doc route in development node
    opts.self ? @route.DocumentationBrowser("doc", [{
      name:"flux:",
      path: @url.normalize('./flux', module.id) .. @url.toPath,
      serve: true,
    }]) : [],

    common.staticRoute,

    @Route(verification.verifyRoute, {GET: verification.verifyHandler}),

    // override modules/master to be executable
    @route.ExecutableDirectory('master', @url.normalize('./modules/master', module.id) .. @url.toPath),

    // and present the rest of modules as code-only (not executable)
    @route.CodeDirectory('modules', @url.normalize('./modules', module.id) .. @url.toPath),

    // serve /ui/* at root
    @route.ExecutableDirectory(@url.normalize('./modules/ui', module.id) .. @url.toPath),

  ] .. common.routeOptions();

  var port = @env.get('port-master');

  try {
    require('seed:master/state').acquire();
  } catch(e) {
    if (!opts.use_existing) throw e;
    @info("Couldn't acquire lockfile - checking for an existing server on port #{port}");
    var serverInfo = runningServerInfo(port);
    if (serverInfo) {
      console.warn("Server already running on port #{port}:", serverInfo);
      return;
    }
    throw e;
  }

  var ssl = opts.ssl;

  var address = opts.Port(port);
  if (opts.ssl) {
    address = address.ssl({
      key: @fs.readFile("#{@env.conductanceRoot}ssl/insecure-localhost.key"),
      cert: @fs.readFile("#{@env.conductanceRoot}ssl/insecure-localhost.crt")
    });
  }

  // discard operations from previous master
  var etcd = @env.get('etcd');
  @etcd.tryOp( -> etcd.del('app/op/', {recursive:true}));

  waitfor {
    require('seed:job/master').main(etcd, {
      //balanceTime: 5,
      balanceTime: 10 * 60,
    });
  } or {
    @server.run({
      address: address,
      routes: routes,
    });
  }
};

//exports.serve = function(args) {
//  waitfor {
//    // XXX shouldn't the process automatically get killed on HUP or something?
//    process.stdin .. @wait('close');
//    console.warn("STDIN CLOSED");
//  } or {
//    serve.apply(this,arguments);
//  }
//};
