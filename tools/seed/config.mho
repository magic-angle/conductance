// Germination server

@ = require('mho:std');
@server = require('mho:server');
require.hubs.push(['app:', @url.normalize('./modules/', module.id)]);

var VERSION = 1;

var runningServerInfo = function(port) {
  try {
    var info = @http.json("http://localhost:#{port}/version");
    // XXX what should we do on version mismatch?
    return info;
  } catch(e) {
    if (e.message .. @contains('ECONNREFUSED')) return false;
    throw e;
  }
}

//----------------------------------------------------------------------
// function invoked by `conductance serve`
var serve = function(args) {
  var parser = require('sjs:dashdash').createParser({
    options: [
      {
        names: ['host'],
        type: 'string',
        help: 'serve on address (default: "localhost". Use "any" to serve on any address")',
        'default': 'localhost',
      },
      {
        names: ['port'],
        type: 'number',
        help: 'serve on port',
        'default': null,
      },
      {
        names: ['anonymous'],
        type: 'bool',
        help: 'allow full access to everyone',
        'default': false,
      },
      {
        names: ['use-existing'],
        type: 'bool',
        help: 'just exit successfully if there\'s already a server running',
        'default': false,
      },
      {
        names: ['ssl'],
        type: 'bool',
        help: 'serve over https (NOTE: uses the default conductance certificate, use for testing only)',
        'default': false,
      },
      { name: 'help', type:'bool'},
    ]
  });
  try {
    var opts = parser.parse(args);
  } catch(e) {
    console.error('Error: ', e.message);
    process.exit(1);
  }

  if (opts.help) {
    console.log("  config.mho options:\n");
    console.log(parser.help({includeEnv:true}));
    process.exit(0);
  }

  @env.set('anonymous-access', opts.anonymous);

  var versionInfo = {
    version: VERSION,
    config: module.id,
    pid: process.pid,
    node_env: process.NODE_ENV || null,
  };

  var routes = [
        @route.SystemRoutes(),
        @Route('version', {GET: function(req) {
          req .. @setHeader('content-type', 'text/json; charset=utf-8');
          req .. @setStatus(200);
          req.response.end(JSON.stringify(versionInfo, null, '  '));
        }}),
        @route.ExecutableDirectory('', @url.normalize('./modules/', module.id) .. @url.toPath),
      ];

  var host = opts.host == 'any' ? null : opts.host;
  var port = opts.port;
  if (!opts.port) {
    console.warn("Please specify --port");
    process.exit(1);
  }

  try {
    require('app:state').acquire();
  } catch(e) {
    if (!opts.use_existing) throw e;
    @info("Couldn't acquire lockfile - checking for an existing server on port #{port}");
    var serverInfo = runningServerInfo(port);
    if (serverInfo) {
      console.warn("Server already running on port #{port}:", serverInfo);
      return;
    }
    throw e;
  }

  var ssl = opts.ssl;

  var address = @Port(port, host);
  if (opts.ssl) {
    address = address.ssl({
      key: @fs.readFile("#{@env.conductanceRoot}ssl/insecure-localhost.key"),
      cert: @fs.readFile("#{@env.conductanceRoot}ssl/insecure-localhost.crt")
    });
  }

  @server.run({
    address: address,
    routes: routes,
  });
};

exports.serve = function(args) {
  waitfor {
    // XXX shouldn't the process automatically get killed on HUP or something?
    process.stdin .. @wait('close');
    console.warn("STDIN CLOSED");
  } or {
    serve.apply(this.arguments);
  }
};
