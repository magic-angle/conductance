@ = require('mho:std');
@stream = require('sjs:nodejs/stream');
@state = require('./state');
@crypto = require('nodejs:crypto');
@tempfile = require('sjs:nodejs/tempfile');
var here = @url.normalize('./', module.id) .. @url.toPath;
var tmpRoot = @path.join(here, '../tmp');
var destRoot = @path.join(here, '../apps');
var credentialsRoot = @path.join(here, '../credentials');
var ConductanceArgs = require('mho:server/systemd').ConductanceArgs;

exports.ping = function() {
  return 'PONG!';
};

var withTmp = function(block) {
  var path, opened;
  try {
    while (true) {
      var idx = Math.round(Math.random() * 100000);
      opened = false;
      path = @path.join(tmpRoot, String(idx));
      try {
        @fs.withWriteStream(path) {|stream|
          opened = true;
          block(stream, path);
        }
        break;
      } catch(e) {
        if (!opened && e.code == 'EEXIST') {
          continue;
        }
        throw e;
      }
    }
  } finally {
    if (opened) {
      @fs.unlink(path);
    }
  }
};

var locks = {};
var apps = {};

var getAppNames = function() {
  return @fs.readdir(destRoot) .. @sort();
};
exports.appNames = @ObservableVar();
exports.appNames.refresh = -> this.set(getAppNames());
exports.appNames.refresh();

var stopApp = function(appname) {
  @assert.fail("TODO: stopApp");
  //var proc = apps[appname];
  //if (proc) {
  //  proc.kill();
  //  proc.wait();
  //  delete apps[appname];
  //}
};

var startApp = function(appname) {
  // ensure stopped
  stopApp(appname);

  // TODO: logging
  apps[appname] = @childProcess.launch(ConductanceArgs[0], ConductanceArgs.slice(1).concat(['serve']), {stdio:['ignore','ignore','ignore']});
};

var appWrapper = function(appname) {
  return {
    name: appname,
    start: -> startApp(appname),
    stop: -> stopApp(appname),
  }
};

var validAppName = name -> /^[a-zA-Z0-9][-_a-zA-Z0-9]*$/.test(name);

var loadUsers = function() {
  return @fs.readFile(@path.join(credentialsRoot, 'users.json'), 'utf-8') .. JSON.parse() .. @get('users');
};

exports.deploy = function(appname, stream) {
  if (!validAppName(appname)) {
    throw new Error("invalid application name: #{appname}");
  }

  if (Object.hasOwnProperty.call(locks, appname)) {
    var date = locks[appname];
    @assert.ok(date);
    throw new Error("a deploy for #{appname} is already running (since #{date.toUTCString()})...");
  }
  locks[appname] = new Date();

  try {
    var expectedSize = 0;
    @tempfile.TemporaryFile({prefix:"conductance-deploy-"}) {|tmpfile|
      console.log("receiving #{appname} -> #{tmpfile.path}");

      var outstream = tmpfile.writeStream();
      stream .. @each {|chunk|
        expectedSize += chunk.length;
        outstream .. @stream.write(chunk);
      }
      outstream .. @stream.end();

      console.log("upload done (#{expectedSize}b), unpacking");
      @assert.ok(expectedSize > 0, "can't deploy an empty file");
      var tmpdest = @path.join(destRoot, "_" + appname);
      var finaldest = @path.join(destRoot, appname);
      
      // XXX
      var cleanup = -> @childProcess.run('rm', ['-rf',tmpdest], {stdio:'inherit'});

      if (@fs.exists(tmpdest)) {
        cleanup();
      }
      @fs.mkdir(tmpdest);
      try {
        @fs.fstat(tmpfile.file).size .. @assert.eq(expectedSize, "uploaded file size");
        @childProcess.run('file', [tmpfile.path], {stdio:'inherit'});
        @childProcess.run('tar', ['xzf', tmpfile.path, '-C', tmpdest], {stdio:'inherit'});

        // sanity check that we have a valid config.mho
        @childProcess.run(ConductanceArgs[0], ConductanceArgs.slice(1).concat([
          'exec',
          @path.join(tmpdest, 'config.mho'),
        ]), {stdio:'inherit'});

        // before we modify anything, kill the old app (if any)
        stopApp(appname);
          
        // overwrite dir
        @fs.rename(tmpdest, finaldest);
        exports.appNames.refresh();

        // and start it
        @assert.fail("TODO: start app...");
        //startApp(appname);
        return appWrapper(appname);
      } catch (e) {
        cleanup();
        throw e;
      }
    }
  } finally {
    locks[appname] = null;
  }
}
